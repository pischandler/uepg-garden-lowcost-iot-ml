<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Smart Tomato Garden</title>
  <style>
:root {
  --bg: #f3f7ef;
  --panel: #fbfef9;
  --ink: #15231b;
  --muted: #55685b;
  --line: #d4e1d4;
  --brand: #2e8e49;
  --brand-2: #c64a2e;
  --ok: #1f9d5b;
  --warn: #b16a12;
  --bad: #b9382d;
  --radius: 16px;
  --shadow: 0 10px 28px rgba(19, 31, 21, 0.08);
  --font-head: "Space Grotesk", "Manrope", "Segoe UI", sans-serif;
  --font-body: "Manrope", "Segoe UI", sans-serif;
}

* { box-sizing: border-box; }
body {
  margin: 0;
  color: var(--ink);
  font-family: var(--font-body);
  background:
    radial-gradient(circle at 10% -10%, #d7f5dd 0%, transparent 42%),
    radial-gradient(circle at 100% 0%, #ffe1d2 0%, transparent 40%),
    var(--bg);
}

.shell {
  max-width: 1280px;
  margin: 0 auto;
  padding: 20px;
  display: grid;
  gap: 14px;
}
.modeTabs {
  display: flex;
  gap: 8px;
  flex-wrap: wrap;
}
.tab {
  border: 1px solid var(--line);
  background: #f5faf4;
  color: #2b4132;
  border-radius: 999px;
  padding: 7px 12px;
  font-weight: 650;
}
.tab.is-active {
  background: #2f8f48;
  color: #fff;
  border-color: transparent;
}
.panel.is-hidden { display: none; }

.hero {
  background: linear-gradient(120deg, #1f7a3d 0%, #2f8f48 52%, #be4e2a 100%);
  color: #f8fff9;
  border-radius: 20px;
  padding: 16px;
  box-shadow: var(--shadow);
}

.heroTop {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 12px;
  flex-wrap: wrap;
}

h1 {
  margin: 0;
  font-family: var(--font-head);
  font-size: clamp(1.2rem, 1.4vw + .8rem, 1.9rem);
}

h2, h3 {
  margin: 0;
  font-family: var(--font-head);
}

h3 { font-size: .95rem; }

.subtitle {
  margin: 4px 0 0;
  opacity: .92;
  font-size: .9rem;
}

.pills {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
  gap: 8px;
  margin-top: 10px;
}

.pill {
  border-radius: 999px;
  border: 1px solid rgba(255, 255, 255, .35);
  padding: 7px 12px;
  display: flex;
  justify-content: space-between;
  gap: 8px;
  background: rgba(255, 255, 255, .08);
  font-size: .88rem;
}

.stack { display: grid; gap: 14px; }
.dashboardGrid {
  display: grid;
  grid-template-columns: repeat(2, minmax(0, 1fr));
  gap: 14px;
}

.card {
  background: var(--panel);
  border: 1px solid var(--line);
  border-radius: var(--radius);
  box-shadow: var(--shadow);
  padding: 13px;
  position: relative;
  overflow: hidden;
}

.card::after {
  content: "";
  position: absolute;
  inset: 0 auto auto 0;
  width: 100%;
  height: 2px;
  background: linear-gradient(90deg, #5fbf72, #df7447);
  opacity: .72;
}

.head {
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: 10px;
  flex-wrap: wrap;
  margin-bottom: 10px;
}

.row { display: flex; flex-wrap: wrap; gap: 8px; align-items: center; }
.grow { flex: 1; }
.mt10 { margin-top: 10px; }
.mt8 { margin-top: 8px; }
.hidden { display: none; }
.syncState {
  color: #eff9f2;
  display: inline-flex;
  align-items: center;
  gap: 6px;
}
.syncState::before {
  content: "";
  width: 8px;
  height: 8px;
  border-radius: 999px;
  background: #8be9a5;
  box-shadow: 0 0 0 0 rgba(139, 233, 165, 0.7);
  animation: ping 1.6s infinite;
}
.syncState.warn::before { background: #ffd18d; }
.syncState.bad::before { background: #ff9f9f; }
@keyframes ping {
  0% { box-shadow: 0 0 0 0 rgba(139, 233, 165, 0.7); }
  100% { box-shadow: 0 0 0 8px rgba(139, 233, 165, 0); }
}
.hud {
  border: 1px solid var(--line);
  border-radius: 999px;
  padding: 2px 8px;
  background: #f5faf4;
}
.safeModeWrap {
  display: inline-flex;
  gap: 6px;
  align-items: center;
  margin-top: 6px;
}

button,
input,
select {
  font: inherit;
  border-radius: 10px;
  border: 1px solid var(--line);
  background: #fff;
  color: var(--ink);
  padding: 8px 10px;
}

button {
  cursor: pointer;
  font-weight: 650;
  transition: transform .08s ease, box-shadow .14s ease;
}
button[disabled] {
  opacity: .7;
  cursor: not-allowed;
}
button:hover { box-shadow: 0 4px 14px rgba(10, 22, 16, .1); }
button:active { transform: translateY(1px); }
button.brand { background: var(--brand); color: #fff; border-color: transparent; }
button.warn { background: #fff4ea; color: #7a4310; }
button.danger { background: #ffecea; color: #7f1f17; }
button.ghost { background: #f4f8f2; color: #2c3e32; }
button.is-loading {
  position: relative;
  padding-left: 32px;
}
button.is-loading::before {
  content: "";
  position: absolute;
  left: 11px;
  top: 50%;
  width: 12px;
  height: 12px;
  margin-top: -6px;
  border-radius: 50%;
  border: 2px solid rgba(32, 60, 44, .25);
  border-top-color: rgba(32, 60, 44, .8);
  animation: spin .8s linear infinite;
}
@keyframes spin {
  to { transform: rotate(360deg); }
}

.status {
  font-size: .83rem;
  border: 1px solid var(--line);
  border-radius: 999px;
  padding: 3px 10px;
  color: var(--muted);
  background: #f5faf4;
}
.status.ok { color: var(--ok); border-color: #9ddab7; background: #effaf3; }
.status.warn { color: var(--warn); border-color: #efcd98; background: #fff8ec; }
.status.bad { color: var(--bad); border-color: #efb7ae; background: #fff1ef; }

.diagnosisCard {
  border: 2px solid var(--line);
  border-radius: 14px;
  background: #fcfffb;
  padding: 12px;
}
.gaugeRow {
  display: grid;
  grid-template-columns: repeat(3, minmax(0, 1fr));
  gap: 10px;
}
.gaugeWrap {
  display: flex;
  align-items: center;
  justify-content: center;
}
.gauge {
  width: 132px;
  height: 132px;
  border-radius: 50%;
  background: conic-gradient(#87cc9c 0deg, #e7efe4 0deg);
  display: grid;
  place-items: center;
  transition: background .25s ease;
}
.gaugeInner {
  width: 96px;
  height: 96px;
  border-radius: 50%;
  background: #fbfef9;
  border: 1px solid var(--line);
  display: grid;
  place-items: center;
  text-align: center;
  padding: 6px;
}
.gaugeInner strong { font-size: 1rem; line-height: 1; }
.gaugeInner span {
  font-size: .72rem;
  color: var(--muted);
  line-height: 1.15;
}

.trendBlock {
  border: 1px solid var(--line);
  border-radius: 12px;
  background: #f8fcf7;
  padding: 8px;
  margin-top: 8px;
}
.trendHead {
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: 8px;
  font-size: .84rem;
  color: var(--muted);
  margin-bottom: 4px;
}
.trendCanvas {
  width: 100%;
  height: 120px;
  background: linear-gradient(180deg, rgba(114, 188, 134, 0.08), rgba(255, 255, 255, 0.2));
  border-radius: 10px;
}

.ring {
  width: 140px;
  height: 140px;
  border-radius: 50%;
  background: conic-gradient(#6fc082 0deg, #e7efe4 0deg);
  display: grid;
  place-items: center;
}
.ringInner {
  width: 100px;
  height: 100px;
  border-radius: 50%;
  background: #fbfef9;
  border: 1px solid var(--line);
  display: grid;
  place-items: center;
  text-align: center;
  padding: 6px;
}
.ringInner strong { font-size: 1rem; }
.ringInner span { font-size: .72rem; color: var(--muted); }
.inferHealthMeta { display: grid; gap: 8px; }

.timelineBars {
  display: grid;
  grid-template-columns: repeat(30, minmax(0, 1fr));
  gap: 3px;
  height: 42px;
  align-items: end;
  border: 1px solid var(--line);
  border-radius: 10px;
  padding: 5px;
  background: #f8fcf7;
}
.timelineBars i {
  display: block;
  height: 20%;
  border-radius: 2px;
  background: #d6e4d6;
}
.timelineBars i.on {
  height: 100%;
  background: linear-gradient(180deg, #52b56f, #2f8f48);
}
.cameraHero {
  border-width: 2px;
  padding: 14px;
}
.cameraFrame {
  width: 100%;
  min-height: 400px;
  max-height: 62vh;
  aspect-ratio: 4 / 3;
  object-fit: contain;
  background: radial-gradient(circle at 50% 50%, #27352d 0%, #1d2a23 100%);
  border: 2px solid #b9cdbd;
  box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.22);
}
.mediaWrap {
  position: relative;
}
.mediaOverlay {
  position: absolute;
  inset: 0;
  display: none;
  align-items: center;
  justify-content: center;
  gap: 10px;
  color: #f5fbf7;
  font-weight: 600;
  background: linear-gradient(180deg, rgba(22, 39, 30, .55), rgba(22, 39, 30, .68));
  border-radius: 12px;
}
.mediaOverlay.loading {
  display: flex;
}
.spinner {
  width: 18px;
  height: 18px;
  border-radius: 50%;
  border: 2px solid rgba(255, 255, 255, .35);
  border-top-color: #fff;
  animation: spin .8s linear infinite;
}
.compactStats {
  grid-template-columns: repeat(2, minmax(140px, 220px));
}
.cameraControls {
  grid-template-columns: repeat(3, minmax(180px, 1fr));
}
.inferenceDock {
  margin-top: 12px;
  border-top: 1px solid var(--line);
  padding-top: 12px;
}
.inferenceGrid {
  display: grid;
  grid-template-columns: 1.1fr 1fr;
  gap: 10px;
  margin-top: 10px;
}
.diagnosisCard.ok { border-color: #92d7ad; }
.diagnosisCard.warn { border-color: #e6c58f; }
.diagnosisCard.bad { border-color: #e8aa9f; }

.diagnosisMain {
  border: 1px solid var(--line);
  border-radius: 12px;
  padding: 12px;
  background: #f8fcf7;
}

.diagnosisMain.loading {
  color: var(--muted);
  background: linear-gradient(90deg, #f2f7f0 0%, #fbfef9 50%, #f2f7f0 100%);
  background-size: 200% 100%;
  animation: pulse 1.4s linear infinite;
}

@keyframes pulse {
  from { background-position: 0 0; }
  to { background-position: 200% 0; }
}

.diagnosisLabel {
  margin: 0;
  font-size: clamp(1.1rem, 1vw + .9rem, 1.6rem);
  font-family: var(--font-head);
  font-weight: 700;
}
.diagnosisSub { margin: 6px 0 0; color: var(--muted); }
.diagnosisMeta { margin: 8px 0 0; font-size: .85rem; color: var(--muted); }
.guidedAlert {
  margin-top: 8px;
  border: 1px solid #f0d1a0;
  border-left: 4px solid #c08a2f;
  border-radius: 10px;
  background: #fff9f0;
  color: #644013;
  padding: 8px;
  font-size: .83rem;
}

.subCard {
  margin-top: 10px;
  border: 1px solid var(--line);
  border-radius: 12px;
  padding: 10px;
  background: #f9fcf8;
}

.topkList { display: grid; gap: 8px; margin-top: 8px; }
.barRow {
  display: grid;
  grid-template-columns: 1fr auto;
  gap: 8px;
  align-items: center;
  font-size: .9rem;
}
.bar {
  height: 10px;
  border-radius: 999px;
  background: #e6eee2;
  overflow: hidden;
  margin-top: 4px;
}
.bar > i {
  display: block;
  height: 100%;
  background: linear-gradient(90deg, #5dbb72, #d06a40);
}

.chipWrap { display: flex; flex-wrap: wrap; gap: 7px; margin-top: 8px; }
.chip {
  border: 1px solid var(--line);
  border-radius: 999px;
  padding: 4px 9px;
  font-size: .82rem;
  color: #304538;
  background: #f4faf2;
}

img {
  width: 100%;
  min-height: 220px;
  border: 1px solid var(--line);
  border-radius: 12px;
  background: #ebf2e8;
}

.meta {
  display: grid;
  grid-template-columns: repeat(2, minmax(0, 1fr));
  gap: 10px;
  margin-top: 10px;
}

.kpi {
  border: 1px solid var(--line);
  border-radius: 12px;
  padding: 10px;
  background: #f8fbf6;
}
.k { color: var(--muted); font-size: .82rem; }
.v { margin-top: 2px; font-weight: 700; font-size: 1.08rem; }

.list, .rightColFields { display: grid; gap: 8px; margin-top: 8px; }
.item {
  border: 1px solid var(--line);
  border-radius: 10px;
  padding: 8px 10px;
  display: flex;
  justify-content: space-between;
  gap: 10px;
  align-items: center;
  background: #f9fbf8;
  font-size: .92rem;
}

.tiny { font-size: .82rem; color: var(--muted); }
input[type="range"] { accent-color: var(--brand); }

.feed {
  margin: 0;
  padding: 0;
  list-style: none;
  max-height: 220px;
  overflow: auto;
  display: grid;
  gap: 8px;
}
.feed li {
  border: 1px solid var(--line);
  border-left: 4px solid #6fae5f;
  border-radius: 10px;
  padding: 8px;
  background: #fbfdf9;
  font-size: .85rem;
}
.emptyFeed {
  border-left-style: dashed !important;
  color: var(--muted);
  text-align: center;
}
.feedTag {
  display: inline-block;
  margin-right: 8px;
  border-radius: 999px;
  border: 1px solid var(--line);
  padding: 1px 7px;
  font-size: .74rem;
  color: #2f4536;
  background: #f0f7ee;
}

.toastStack {
  position: fixed;
  right: 14px;
  bottom: 14px;
  display: grid;
  gap: 8px;
  z-index: 1200;
  pointer-events: none;
}
.toast {
  min-width: 220px;
  max-width: 340px;
  pointer-events: auto;
  border: 1px solid var(--line);
  border-left: 4px solid #6db37e;
  border-radius: 12px;
  background: #fbfefa;
  color: #21372a;
  box-shadow: var(--shadow);
  padding: 9px 10px;
  font-size: .86rem;
}
.toast.warn { border-left-color: #ce8c31; background: #fffbf4; }
.toast.bad { border-left-color: #d06054; background: #fff7f6; }

details {
  border: 1px dashed var(--line);
  border-radius: 10px;
  padding: 8px;
  background: #fafdfa;
}
summary { cursor: pointer; font-weight: 650; }

.debugBlock { margin-top: 10px; }
.debugGrid {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 10px;
}

.opsGrid {
  display: grid;
  grid-template-columns: repeat(2, minmax(0, 1fr));
  gap: 14px;
}
.wide { grid-column: 1 / -1; }

pre {
  margin: 8px 0 0;
  font-size: .78rem;
  color: #1f3629;
  white-space: pre-wrap;
  word-break: break-word;
  max-height: 240px;
  overflow: auto;
}

@media (max-width: 990px) {
  .shell { padding: 14px; }
  .cameraFrame {
    min-height: 260px;
    max-height: 48vh;
  }
  .cameraControls {
    grid-template-columns: 1fr;
  }
  .inferenceGrid,
  .debugGrid,
  .opsGrid,
  .dashboardGrid {
    grid-template-columns: 1fr;
  }
  .gaugeRow {
    grid-template-columns: 1fr;
  }
  .compactStats {
    grid-template-columns: 1fr 1fr;
  }
  .toastStack {
    right: 10px;
    left: 10px;
  }
  .toast {
    max-width: none;
    width: 100%;
  }
  .modeTabs { justify-content: stretch; }
  .tab { flex: 1; text-align: center; }
}
  </style>
</head>
<body>
  <main class="shell">
    <nav class="modeTabs" aria-label="Modo do painel">
      <button class="tab is-active" data-tab="overview" data-i18n="tab.overview">Visao geral</button>
      <button class="tab" data-tab="camera" data-i18n="tab.camera">Camera</button>
      <button class="tab" data-tab="irrigation" data-i18n="tab.irrigation">Irrigacao</button>
      <button class="tab" data-tab="technical" data-i18n="tab.technical">Tecnico</button>
    </nav>

    <section class="hero">
      <div class="heroTop">
        <div>
          <h1 data-i18n="app.title">Smart Tomato Garden</h1>
          <p class="subtitle" data-i18n="app.subtitle">Monitoramento e controle em tempo real</p>
        </div>
        <div class="row">
          <label for="langSelect" class="tiny" data-i18n="label.language">Idioma</label>
          <select id="langSelect">
            <option value="pt" data-i18n="lang.pt">PT</option>
            <option value="en" data-i18n="lang.en">EN</option>
            <option value="cn" data-i18n="lang.cn">中文</option>
          </select>
          <span class="tiny syncState" id="syncState" data-i18n="status.syncing" aria-live="polite">Sincronizando...</span>
          <span class="status" id="onlineState" data-i18n="status.connecting" aria-live="polite">Conectando...</span>
          <button id="btnRefresh" class="ghost" data-i18n="action.refresh_all">Atualizar tudo</button>
        </div>
      </div>
      <div class="pills">
        <div class="pill"><span data-i18n="pill.device">Dispositivo</span><strong id="device">...</strong></div>
        <div class="pill"><span data-i18n="pill.ip">IP</span><strong id="ip">...</strong></div>
        <div class="pill"><span data-i18n="pill.rssi">RSSI</span><strong id="rssi">...</strong></div>
        <div class="pill"><span data-i18n="pill.uptime">Uptime</span><strong id="uptime">...</strong></div>
      </div>
    </section>

    <section class="dashboardGrid panel" data-panel="overview">
      <article class="card">
        <div class="head">
          <h2 data-i18n="dashboard.realtime">Painel em tempo real</h2>
          <span class="tiny" data-i18n="dashboard.live_now">agora</span>
        </div>
        <div class="gaugeRow">
          <div class="gaugeWrap">
            <div class="gauge" id="gaugeSoil">
              <div class="gaugeInner"><strong id="gaugeSoilV">-</strong><span data-i18n="sensor.soil_humidity">Umidade do solo</span></div>
            </div>
          </div>
          <div class="gaugeWrap">
            <div class="gauge" id="gaugeHum">
              <div class="gaugeInner"><strong id="gaugeHumV">-</strong><span data-i18n="sensor.air_humidity">Umidade do ar</span></div>
            </div>
          </div>
          <div class="gaugeWrap">
            <div class="gauge" id="gaugeTemp">
              <div class="gaugeInner"><strong id="gaugeTempV">-</strong><span data-i18n="sensor.temperature">Temperatura</span></div>
            </div>
          </div>
        </div>
      </article>

      <article class="card">
        <div class="head">
          <h2 data-i18n="dashboard.trends">Tendencias</h2>
          <div class="row">
            <label for="trendRange" class="tiny" data-i18n="dashboard.range">janela</label>
            <select id="trendRange">
              <option value="5m">5m</option>
              <option value="30m" selected>30m</option>
              <option value="2h">2h</option>
            </select>
            <button id="btnExportTrends" class="ghost" data-i18n="dashboard.export_csv">Exportar CSV</button>
          </div>
        </div>
        <div class="trendBlock">
          <div class="trendHead">
            <span data-i18n="sensor.temperature">Temperatura</span>
            <strong id="trendTempMeta">-</strong>
          </div>
          <canvas id="trendTemp" class="trendCanvas" width="620" height="140"></canvas>
        </div>
        <div class="trendBlock">
          <div class="trendHead">
            <span data-i18n="sensor.soil_humidity">Umidade do solo</span>
            <strong id="trendSoilMeta">-</strong>
          </div>
          <canvas id="trendSoil" class="trendCanvas" width="620" height="140"></canvas>
        </div>
      </article>

      <article class="card">
        <div class="head">
          <h2 data-i18n="dashboard.inference_health">Saude da inferencia</h2>
          <span class="tiny" data-i18n="dashboard.model_view">modelo</span>
        </div>
        <div class="row">
          <div class="ring" id="inferRing">
            <div class="ringInner">
              <strong id="inferRate">-</strong>
              <span data-i18n="dashboard.success_rate">taxa de acerto</span>
            </div>
          </div>
          <div class="grow inferHealthMeta">
            <div class="item"><span data-i18n="dashboard.last_latency">Ultima latencia</span><strong id="inferLatency">-</strong></div>
            <div class="item"><span data-i18n="dashboard.infer_attempts">Tentativas</span><strong id="inferAttempt">-</strong></div>
            <div class="item"><span data-i18n="dashboard.infer_failures">Falhas</span><strong id="inferFail">-</strong></div>
          </div>
        </div>
      </article>

      <article class="card">
        <div class="head">
          <h2 data-i18n="dashboard.pump_activity">Atividade da bomba</h2>
          <span class="tiny" data-i18n="dashboard.recent_window">janela recente</span>
        </div>
        <div id="pumpTimeline" class="timelineBars"></div>
        <div class="item mt8">
          <span data-i18n="dashboard.pump_duty">Duty cycle</span>
          <strong id="pumpDuty">-</strong>
        </div>
      </article>
    </section>

    <section class="cameraHero card panel" data-panel="overview camera">
      <div class="head">
        <h2 data-i18n="section.camera_live">Camera ao vivo</h2>
        <div class="row">
          <span class="status" id="streamState" data-i18n="status.stream_active">Stream ativo</span>
          <span class="tiny hud" id="hudTransport">mode -</span>
          <span class="tiny hud" id="hudFps">fps -</span>
          <span class="tiny hud" id="hudReconnect">reconnect 0</span>
          <label for="streamProfile" class="tiny" data-i18n="label.stream_profile">Perfil</label>
          <select id="streamProfile">
            <option value="auto" data-i18n="stream.profile_auto">Auto</option>
            <option value="stable" data-i18n="stream.profile_stable">Estavel</option>
            <option value="fast" data-i18n="stream.profile_fast">Rapido</option>
          </select>
          <button id="btnStream" class="ghost" data-i18n="action.pause_stream">Pausar stream</button>
          <button id="btnSnap" class="brand" data-i18n="action.capture_photo">Capturar foto</button>
        </div>
      </div>
      <div class="tiny" id="streamHint" data-i18n="stream.mode_hint_auto_mjpeg">Auto: modo rapido</div>
      <label class="tiny safeModeWrap" for="safeMode">
        <input id="safeMode" type="checkbox">
        <span data-i18n="stream.safe_mode">Modo seguro de stream</span>
      </label>
      <div class="mediaWrap">
        <img id="view" class="cameraFrame" src="/stream" alt="camera stream">
        <div class="mediaOverlay loading" id="cameraOverlay">
          <span class="spinner"></span>
          <span data-i18n="loading.camera">Carregando camera...</span>
        </div>
      </div>
      <div class="meta compactStats">
        <div class="kpi"><div class="k" data-i18n="metric.stream_clients">Clientes no stream</div><div class="v" id="streamClients">0</div></div>
        <div class="kpi"><div class="k" data-i18n="metric.total_captures">Capturas totais</div><div class="v" id="captureCount">0</div></div>
      </div>
      <div class="list cameraControls">
        <div class="item">
          <label for="framesize" data-i18n="label.resolution">Resolucao</label>
          <select id="framesize">
            <option value="5">QVGA (320x240)</option>
            <option value="6">CIF (400x296)</option>
            <option value="8">VGA (640x480)</option>
            <option value="9">SVGA (800x600)</option>
            <option value="10">XGA (1024x768)</option>
            <option value="12">UXGA (1600x1200)</option>
          </select>
        </div>
        <div class="item">
          <label for="quality" data-i18n="label.jpeg_quality">Qualidade JPEG</label>
          <div class="row"><input id="quality" type="range" min="10" max="63" step="1"><strong id="qualityV">-</strong></div>
        </div>
        <div class="item">
          <label for="led" data-i18n="label.camera_led">LED da camera</label>
          <div class="row"><input id="led" type="range" min="0" max="255" step="1"><strong id="ledV">-</strong></div>
        </div>
      </div>

      <section class="inferenceDock">
        <div class="diagnosisCard" id="diagnosisCard">
          <div class="head">
            <h2 data-i18n="section.current_diagnosis">Diagnostico Atual</h2>
            <div class="row">
              <span class="status" id="diagnosisStatus" data-i18n="status.loading" aria-live="polite">Carregando...</span>
              <button id="btnRunInference" class="brand" data-i18n="action.run_inference">Rodar inferencia</button>
            </div>
          </div>
          <div class="diagnosisMain loading" id="diagnosisMain">
            <p class="diagnosisLabel" id="diagLabel" data-i18n="diagnosis.no_recent">Sem inferencia recente</p>
            <p class="diagnosisSub" id="diagSub" data-i18n="diagnosis.waiting_data">Aguardando dados</p>
            <p class="diagnosisMeta" id="diagMeta">latencia - | HTTP - | horario -</p>
          </div>
          <div id="guidedAlert" class="guidedAlert hidden" aria-live="polite"></div>
          <div class="row">
            <button id="btnRetrySync" class="warn hidden" data-i18n="action.retry">Tentar novamente</button>
          </div>
          <div class="inferenceGrid">
            <div class="subCard">
              <h3 data-i18n="sub.top_probabilities">Top probabilidades</h3>
              <div id="topkList" class="topkList">
                <p class="tiny" data-i18n="state.no_data_show">Sem dados para exibir.</p>
              </div>
            </div>
            <div class="subCard">
              <h3 data-i18n="sub.capture_context">Contexto da captura</h3>
              <div id="contextChips" class="chipWrap">
                <span class="chip" data-i18n="state.no_recent_context">Sem contexto recente</span>
              </div>
            </div>
          </div>
        </div>
      </section>
    </section>

    <section class="opsGrid panel" data-panel="overview irrigation">
      <article class="card" data-panel-card="sensors">
        <div class="head">
          <h2 data-i18n="section.sensors">Sensores do ambiente</h2>
          <span class="status" id="sensorFresh" data-i18n="status.reading">Lendo...</span>
        </div>
        <div class="meta">
          <div class="kpi"><div class="k" data-i18n="sensor.soil_humidity">Umidade do solo</div><div class="v" id="soilPct">...</div></div>
          <div class="kpi"><div class="k" data-i18n="sensor.soil_raw">Solo bruto (ADC)</div><div class="v" id="soilRaw">...</div></div>
          <div class="kpi"><div class="k" data-i18n="sensor.lux_raw">Luminosidade (ADC)</div><div class="v" id="luxRaw">...</div></div>
          <div class="kpi"><div class="k" data-i18n="sensor.temperature">Temperatura</div><div class="v" id="tempC">...</div></div>
          <div class="kpi"><div class="k" data-i18n="sensor.air_humidity">Umidade do ar</div><div class="v" id="humPct">...</div></div>
          <div class="kpi"><div class="k" data-i18n="sensor.dht">DHT22</div><div class="v" id="dhtOk">...</div></div>
        </div>
      </article>

      <article class="card" data-panel-card="irrigation">
        <div class="head">
          <h2 data-i18n="section.irrigation">Irrigacao</h2>
          <span class="status" id="pumpState" data-i18n="status.pump_off">Bomba desligada</span>
        </div>
        <div class="rightColFields">
          <div class="item"><span data-i18n="irrigation.auto_mode">Modo automatico</span><strong id="autoMode">...</strong></div>
          <div class="item"><span data-i18n="irrigation.pump_remaining">Tempo restante da bomba</span><strong id="pumpRemaining">0 ms</strong></div>
          <div class="item"><span data-i18n="irrigation.cooldown_remaining">Cooldown restante</span><strong id="cooldownRemaining">0 ms</strong></div>
          <div class="item"><span data-i18n="irrigation.dry_threshold">Limiar de solo seco</span><strong id="dryThreshold">...</strong></div>
        </div>
        <div class="row mt10">
          <input id="irrigationMs" type="number" min="200" max="30000" step="100" value="1500" class="grow">
          <button id="btnIrrigate" class="brand" data-i18n="action.irrigate_now">Irrigar agora</button>
          <button id="btnStop" class="danger" data-i18n="action.stop">Parar</button>
        </div>
        <div class="row mt8">
          <button data-ms="1500" class="quick ghost">1.5s</button>
          <button data-ms="5000" class="quick ghost">5s</button>
          <button data-ms="10000" class="quick ghost">10s</button>
        </div>
      </article>

      <article class="card" data-panel-card="health">
        <div class="head">
          <h2 data-i18n="section.health">Saude e telemetria</h2>
          <span class="tiny" id="lastSync" data-i18n="status.no_sync">sem sincronizacao</span>
        </div>
        <div class="rightColFields">
          <div class="item"><span data-i18n="health.heap_free">Heap livre</span><strong id="heap">...</strong></div>
          <div class="item"><span data-i18n="health.psram_free">PSRAM livre</span><strong id="psram">...</strong></div>
          <div class="item"><span data-i18n="health.http_requests">HTTP requests</span><strong id="httpCount">...</strong></div>
          <div class="item"><span data-i18n="health.mqtt_pub">Publicacoes MQTT</span><strong id="mqttPub">...</strong></div>
          <div class="item"><span data-i18n="health.mqtt_fail">Falhas MQTT</span><strong id="mqttFail">...</strong></div>
          <div class="item"><span data-i18n="health.infer_ok">Inferencias OK</span><strong id="inferOk">...</strong></div>
        </div>
      </article>

      <article class="card" data-panel-card="events">
        <div class="head">
          <h2 data-i18n="section.events">Eventos recentes</h2>
          <span class="tiny" data-i18n="events.last_20">ultimos 20 eventos</span>
        </div>
        <ul class="feed" id="feed" aria-live="polite">
          <li class="emptyFeed" data-i18n="events.none">Nenhum evento ainda</li>
        </ul>
      </article>

      <article class="card wide panel" data-panel="technical">
        <details>
          <summary data-i18n="section.tech_mode">Modo tecnico (JSON)</summary>
          <div class="debugGrid">
            <div class="debugBlock">
              <h3 data-i18n="section.last_inference">Ultima inferencia</h3>
              <pre id="inferenceJson">sem dados</pre>
            </div>
            <div class="debugBlock">
              <h3 data-i18n="section.raw_debug">Debug bruto</h3>
              <pre id="rawJson">sem dados</pre>
            </div>
          </div>
        </details>
      </article>
    </section>
  </main>
  <div id="toastStack" class="toastStack" aria-live="polite"></div>

  <script>
window.__STG_I18N_DICTS__ = {pt:{
  "app.title": "Smart Tomato Garden",
  "app.subtitle": "Monitoramento e controle em tempo real",
  "status.connecting": "Conectando...",
  "status.syncing": "Sincronizando...",
  "status.updated_now": "Atualizado agora",
  "status.no_connection": "Sem conexao",
  "status.online": "Online",
  "status.offline": "Offline",
  "status.sync_fail": "Falha na sincronizacao",
  "action.refresh_all": "Atualizar tudo",
  "pill.device": "Dispositivo",
  "pill.ip": "IP",
  "pill.rssi": "RSSI",
  "pill.uptime": "Uptime",
  "section.camera_live": "Camera ao vivo",
  "status.stream_active": "Stream ativo",
  "status.stream_paused": "Stream pausado",
  "action.pause_stream": "Pausar stream",
  "action.resume_stream": "Retomar stream",
  "action.capture_photo": "Capturar foto",
  "loading.camera": "Carregando camera...",
  "loading.capture": "Carregando captura...",
  "metric.stream_clients": "Clientes no stream",
  "metric.total_captures": "Capturas totais",
  "label.resolution": "Resolucao",
  "label.jpeg_quality": "Qualidade JPEG",
  "label.camera_led": "LED da camera",
  "label.stream_profile": "Perfil",
  "stream.profile_auto": "Auto",
  "stream.profile_stable": "Estavel",
  "stream.profile_fast": "Rapido",
  "stream.mode_hint_auto_mjpeg": "Auto: modo rapido (MJPEG)",
  "stream.mode_hint_auto_snapshot": "Auto: modo estavel por resolucao/movimento",
  "stream.mode_hint_forced_stable": "Perfil estavel ativo (/capture em loop)",
  "stream.mode_hint_forced_fast": "Perfil rapido ativo (MJPEG)",
  "section.current_diagnosis": "Diagnostico Atual",
  "status.loading": "Carregando...",
  "action.run_inference": "Rodar inferencia",
  "action.retry": "Tentar novamente",
  "diagnosis.no_recent": "Sem inferencia recente",
  "diagnosis.waiting_data": "Aguardando dados",
  "diagnosis.meta_line": "latencia {latency} | HTTP {http} | horario {time}",
  "diagnosis.confidence": "Confianca: {value}%",
  "diagnosis.reasons": "Motivos: {value}",
  "diagnosis.awaiting": "Aguardando dados de inferencia",
  "diagnosis.confident": "Confiavel",
  "diagnosis.low_confidence": "Baixa confianca",
  "diagnosis.fail": "Falha de inferencia",
  "diagnosis.no_data": "Sem dados",
  "sub.top_probabilities": "Top probabilidades",
  "sub.capture_context": "Contexto da captura",
  "state.no_data_show": "Sem dados para exibir.",
  "state.no_recent_context": "Sem contexto recente",
  "chip.temp": "Temp {value}",
  "chip.air_humidity": "Umid ar {value}",
  "chip.light": "Luz {value}",
  "chip.soil": "Solo {value}",
  "chip.pump": "Bomba {value}",
  "pump.on": "ligada",
  "pump.off": "desligada",
  "section.sensors": "Sensores do ambiente",
  "status.reading": "Lendo...",
  "sensor.updated_ago": "Atualizado ha {age}",
  "sensor.delayed": "Leitura atrasada ({age})",
  "sensor.stale": "Sem leitura recente ({age})",
  "sensor.soil_humidity": "Umidade do solo",
  "sensor.soil_raw": "Solo bruto (ADC)",
  "sensor.lux_raw": "Luminosidade (ADC)",
  "sensor.temperature": "Temperatura",
  "sensor.air_humidity": "Umidade do ar",
  "sensor.dht": "DHT22",
  "status.ok": "OK",
  "status.fail": "Falha",
  "section.irrigation": "Irrigacao",
  "status.pump_off": "Bomba desligada",
  "status.pump_on": "Bomba ligada",
  "status.cooldown_wait": "Aguardando cooldown",
  "irrigation.auto_mode": "Modo automatico",
  "irrigation.pump_remaining": "Tempo restante da bomba",
  "irrigation.cooldown_remaining": "Cooldown restante",
  "irrigation.dry_threshold": "Limiar de solo seco",
  "state.active": "Ativo",
  "state.disabled": "Desativado",
  "action.irrigate_now": "Irrigar agora",
  "action.stop": "Parar",
  "section.health": "Saude e telemetria",
  "status.no_sync": "sem sincronizacao",
  "status.synced_at": "sincronizado {time}",
  "health.heap_free": "Heap livre",
  "health.psram_free": "PSRAM livre",
  "health.http_requests": "HTTP requests",
  "health.mqtt_pub": "Publicacoes MQTT",
  "health.mqtt_fail": "Falhas MQTT",
  "health.infer_ok": "Inferencias OK",
  "section.events": "Eventos recentes",
  "events.last_20": "ultimos 20 eventos",
  "events.none": "Nenhum evento ainda",
  "section.tech_mode": "Modo tecnico (JSON)",
  "section.last_inference": "Ultima inferencia",
  "section.raw_debug": "Debug bruto",
  "dashboard.realtime": "Painel em tempo real",
  "dashboard.live_now": "agora",
  "dashboard.trends": "Tendencias",
  "dashboard.last_cycles": "ultimos ciclos",
  "dashboard.inference_health": "Saude da inferencia",
  "dashboard.model_view": "modelo",
  "dashboard.success_rate": "taxa de acerto",
  "dashboard.last_latency": "Ultima latencia",
  "dashboard.infer_attempts": "Tentativas",
  "dashboard.infer_failures": "Falhas",
  "dashboard.pump_activity": "Atividade da bomba",
  "dashboard.recent_window": "janela recente",
  "dashboard.pump_duty": "Duty cycle",
  "dashboard.range": "janela",
  "dashboard.export_csv": "Exportar CSV",
  "tab.overview": "Visao geral",
  "tab.camera": "Camera",
  "tab.irrigation": "Irrigacao",
  "tab.technical": "Tecnico",
  "stream.safe_mode": "Modo seguro de stream",
  "stream.safe_mode_on": "Modo seguro ativado",
  "stream.safe_mode_off": "Modo seguro desativado",
  "guided.infer_fail": "Falha na inferencia. Revise iluminacao, foco e tente novamente em resolucao menor.",
  "guided.low_conf": "Confianca baixa: {reasons}. Acao sugerida: estabilize imagem e rode nova inferencia.",
  "camera.load_fail_reconnect": "Falha no stream, tentando reconectar...",
  "camera.stream_fail": "Falha no stream da camera",
  "camera.photo_captured": "Foto capturada",
  "camera.photo_capture_failed": "Falha ao capturar foto",
  "camera.stream_resumed": "Stream retomado",
  "camera.stream_paused": "Stream pausado",
  "camera.quality_set": "Qualidade JPEG ajustada para {value}",
  "camera.quality_set_fail": "Falha ao ajustar qualidade",
  "camera.resolution_set": "Resolucao alterada para {value}",
  "camera.resolution_set_fail": "Falha ao alterar resolucao",
  "camera.high_res_warning": "VGA com muito movimento pode congelar. Para stream estavel, use QVGA/CIF.",
  "camera.led_set": "LED da camera ajustado para {value}",
  "camera.led_set_fail": "Falha ao ajustar LED",
  "refresh.done": "Atualizacao manual concluida",
  "refresh.done_toast": "Atualizacao concluida",
  "connection.restored": "Conexao restabelecida",
  "connection.restored_toast": "Conexao restabelecida",
  "sync.error": "Erro de sincronizacao: {error}",
  "sync.error_toast": "Erro de sincronizacao",
  "boot.started": "Painel iniciado",
  "boot.started_toast": "Painel iniciado",
  "boot.fail": "Falha no boot: {error}",
  "inference.requested": "Inferencia solicitada",
  "inference.requested_toast": "Inferencia solicitada",
  "inference.request_failed": "Falha ao solicitar inferencia",
  "irrigation.started": "Irrigacao iniciada por {duration}",
  "irrigation.started_toast": "Irrigacao iniciada",
  "irrigation.start_failed": "Falha ao iniciar irrigacao",
  "irrigation.stopped": "Irrigacao interrompida manualmente",
  "irrigation.stopped_toast": "Irrigacao interrompida",
  "irrigation.stop_failed": "Falha ao parar irrigacao",
  "generic.error": "Erro: {error}",
  "generic.action_failed": "Falha: {error}",
  "diagnosis.load_failed": "Nao foi possivel carregar",
  "diagnosis.error_connection": "Erro de conexao",
  "unit.ms": "ms",
  "unit.celsius": "C",
  "class.Tomato_Leaf_Mold": "Mofo da folha",
  "class.Tomato_Early_blight": "Pinta preta (inicial)",
  "class.Tomato__Target_Spot": "Mancha-alvo",
  "class.Tomato_Late_blight": "Requeima",
  "class.Tomato_Septoria_leaf_spot": "Mancha de septoria",
  "class.Tomato_Bacterial_spot": "Mancha bacteriana",
  "class.Tomato_healthy": "Folha saudavel",
  "reason.low_light": "Pouca luz",
  "reason.blurry": "Imagem borrada",
  "reason.low_lux_skip": "Captura sem luz suficiente",
  "reason.infer_host_empty": "Servidor de inferencia nao configurado",
  "reason.camera_fb_get_fail": "Falha ao capturar imagem",
  "reason.http_fail": "Falha de comunicacao com a inferencia",
  "reason.wifi_disconnected": "Wi-Fi desconectado",
  "reason.unknown": "Falha desconhecida",
  "label.language": "Idioma",
  "lang.pt": "PT",
  "lang.en": "EN",
  "lang.cn": "中文"
}
,en:{
  "app.title": "Smart Tomato Garden",
  "app.subtitle": "Real-time monitoring and control",
  "status.connecting": "Connecting...",
  "status.syncing": "Syncing...",
  "status.updated_now": "Updated just now",
  "status.no_connection": "No connection",
  "status.online": "Online",
  "status.offline": "Offline",
  "status.sync_fail": "Sync failed",
  "action.refresh_all": "Refresh all",
  "pill.device": "Device",
  "pill.ip": "IP",
  "pill.rssi": "RSSI",
  "pill.uptime": "Uptime",
  "section.camera_live": "Live camera",
  "status.stream_active": "Stream active",
  "status.stream_paused": "Stream paused",
  "action.pause_stream": "Pause stream",
  "action.resume_stream": "Resume stream",
  "action.capture_photo": "Capture photo",
  "loading.camera": "Loading camera...",
  "loading.capture": "Loading capture...",
  "metric.stream_clients": "Stream clients",
  "metric.total_captures": "Total captures",
  "label.resolution": "Resolution",
  "label.jpeg_quality": "JPEG quality",
  "label.camera_led": "Camera LED",
  "label.stream_profile": "Profile",
  "stream.profile_auto": "Auto",
  "stream.profile_stable": "Stable",
  "stream.profile_fast": "Fast",
  "stream.mode_hint_auto_mjpeg": "Auto: fast mode (MJPEG)",
  "stream.mode_hint_auto_snapshot": "Auto: stability mode due to resolution/motion",
  "stream.mode_hint_forced_stable": "Stable profile active (/capture loop)",
  "stream.mode_hint_forced_fast": "Fast profile active (MJPEG)",
  "section.current_diagnosis": "Current diagnosis",
  "status.loading": "Loading...",
  "action.run_inference": "Run inference",
  "action.retry": "Retry",
  "diagnosis.no_recent": "No recent inference",
  "diagnosis.waiting_data": "Waiting for data",
  "diagnosis.meta_line": "latency {latency} | HTTP {http} | time {time}",
  "diagnosis.confidence": "Confidence: {value}%",
  "diagnosis.reasons": "Reasons: {value}",
  "diagnosis.awaiting": "Waiting for inference data",
  "diagnosis.confident": "Confident",
  "diagnosis.low_confidence": "Low confidence",
  "diagnosis.fail": "Inference failed",
  "diagnosis.no_data": "No data",
  "sub.top_probabilities": "Top probabilities",
  "sub.capture_context": "Capture context",
  "state.no_data_show": "No data to display.",
  "state.no_recent_context": "No recent context",
  "chip.temp": "Temp {value}",
  "chip.air_humidity": "Air hum {value}",
  "chip.light": "Light {value}",
  "chip.soil": "Soil {value}",
  "chip.pump": "Pump {value}",
  "pump.on": "on",
  "pump.off": "off",
  "section.sensors": "Environment sensors",
  "status.reading": "Reading...",
  "sensor.updated_ago": "Updated {age} ago",
  "sensor.delayed": "Delayed reading ({age})",
  "sensor.stale": "No recent reading ({age})",
  "sensor.soil_humidity": "Soil humidity",
  "sensor.soil_raw": "Soil raw (ADC)",
  "sensor.lux_raw": "Luminosity (ADC)",
  "sensor.temperature": "Temperature",
  "sensor.air_humidity": "Air humidity",
  "sensor.dht": "DHT22",
  "status.ok": "OK",
  "status.fail": "Fail",
  "section.irrigation": "Irrigation",
  "status.pump_off": "Pump off",
  "status.pump_on": "Pump on",
  "status.cooldown_wait": "Cooldown wait",
  "irrigation.auto_mode": "Automatic mode",
  "irrigation.pump_remaining": "Pump time left",
  "irrigation.cooldown_remaining": "Cooldown left",
  "irrigation.dry_threshold": "Dry soil threshold",
  "state.active": "Active",
  "state.disabled": "Disabled",
  "action.irrigate_now": "Irrigate now",
  "action.stop": "Stop",
  "section.health": "Health and telemetry",
  "status.no_sync": "no sync",
  "status.synced_at": "synced {time}",
  "health.heap_free": "Free heap",
  "health.psram_free": "Free PSRAM",
  "health.http_requests": "HTTP requests",
  "health.mqtt_pub": "MQTT publishes",
  "health.mqtt_fail": "MQTT failures",
  "health.infer_ok": "Inference OK",
  "section.events": "Recent events",
  "events.last_20": "last 20 events",
  "events.none": "No events yet",
  "section.tech_mode": "Technical mode (JSON)",
  "section.last_inference": "Last inference",
  "section.raw_debug": "Raw debug",
  "dashboard.realtime": "Realtime dashboard",
  "dashboard.live_now": "now",
  "dashboard.trends": "Trends",
  "dashboard.last_cycles": "latest cycles",
  "dashboard.inference_health": "Inference health",
  "dashboard.model_view": "model",
  "dashboard.success_rate": "success rate",
  "dashboard.last_latency": "Last latency",
  "dashboard.infer_attempts": "Attempts",
  "dashboard.infer_failures": "Failures",
  "dashboard.pump_activity": "Pump activity",
  "dashboard.recent_window": "recent window",
  "dashboard.pump_duty": "Duty cycle",
  "dashboard.range": "range",
  "dashboard.export_csv": "Export CSV",
  "tab.overview": "Overview",
  "tab.camera": "Camera",
  "tab.irrigation": "Irrigation",
  "tab.technical": "Technical",
  "stream.safe_mode": "Safe stream mode",
  "stream.safe_mode_on": "Safe mode enabled",
  "stream.safe_mode_off": "Safe mode disabled",
  "guided.infer_fail": "Inference failed. Check lighting/focus and retry at a lower resolution.",
  "guided.low_conf": "Low confidence: {reasons}. Suggested action: stabilize frame and rerun inference.",
  "camera.load_fail_reconnect": "Stream failed, retrying...",
  "camera.stream_fail": "Camera stream failed",
  "camera.photo_captured": "Photo captured",
  "camera.photo_capture_failed": "Failed to capture photo",
  "camera.stream_resumed": "Stream resumed",
  "camera.stream_paused": "Stream paused",
  "camera.quality_set": "JPEG quality set to {value}",
  "camera.quality_set_fail": "Failed to set quality",
  "camera.resolution_set": "Resolution changed to {value}",
  "camera.resolution_set_fail": "Failed to change resolution",
  "camera.high_res_warning": "VGA with high motion may freeze. For stable streaming, use QVGA/CIF.",
  "camera.led_set": "Camera LED set to {value}",
  "camera.led_set_fail": "Failed to set camera LED",
  "refresh.done": "Manual refresh completed",
  "refresh.done_toast": "Refresh completed",
  "connection.restored": "Connection restored",
  "connection.restored_toast": "Connection restored",
  "sync.error": "Sync error: {error}",
  "sync.error_toast": "Sync error",
  "boot.started": "Panel started",
  "boot.started_toast": "Panel started",
  "boot.fail": "Boot failed: {error}",
  "inference.requested": "Inference requested",
  "inference.requested_toast": "Inference requested",
  "inference.request_failed": "Failed to request inference",
  "irrigation.started": "Irrigation started for {duration}",
  "irrigation.started_toast": "Irrigation started",
  "irrigation.start_failed": "Failed to start irrigation",
  "irrigation.stopped": "Irrigation manually stopped",
  "irrigation.stopped_toast": "Irrigation stopped",
  "irrigation.stop_failed": "Failed to stop irrigation",
  "generic.error": "Error: {error}",
  "generic.action_failed": "Failed: {error}",
  "diagnosis.load_failed": "Unable to load data",
  "diagnosis.error_connection": "Connection error",
  "unit.ms": "ms",
  "unit.celsius": "C",
  "class.Tomato_Leaf_Mold": "Leaf mold",
  "class.Tomato_Early_blight": "Early blight",
  "class.Tomato__Target_Spot": "Target spot",
  "class.Tomato_Late_blight": "Late blight",
  "class.Tomato_Septoria_leaf_spot": "Septoria leaf spot",
  "class.Tomato_Bacterial_spot": "Bacterial spot",
  "class.Tomato_healthy": "Healthy leaf",
  "reason.low_light": "Low light",
  "reason.blurry": "Blurry image",
  "reason.low_lux_skip": "Skipped due to low light",
  "reason.infer_host_empty": "Inference server is not configured",
  "reason.camera_fb_get_fail": "Image capture failed",
  "reason.http_fail": "Inference communication failed",
  "reason.wifi_disconnected": "Wi-Fi disconnected",
  "reason.unknown": "Unknown failure",
  "label.language": "Language",
  "lang.pt": "PT",
  "lang.en": "EN",
  "lang.cn": "中文"
}
,cn:{
  "app.title": "智能番茄花园",
  "app.subtitle": "实时监控与控制",
  "status.connecting": "连接中...",
  "status.syncing": "同步中...",
  "status.updated_now": "刚刚更新",
  "status.no_connection": "无连接",
  "status.online": "在线",
  "status.offline": "离线",
  "status.sync_fail": "同步失败",
  "action.refresh_all": "刷新全部",
  "pill.device": "设备",
  "pill.ip": "IP",
  "pill.rssi": "RSSI",
  "pill.uptime": "运行时间",
  "section.camera_live": "实时摄像头",
  "status.stream_active": "视频流开启",
  "status.stream_paused": "视频流暂停",
  "action.pause_stream": "暂停视频流",
  "action.resume_stream": "恢复视频流",
  "action.capture_photo": "拍照",
  "loading.camera": "摄像头加载中...",
  "loading.capture": "抓拍加载中...",
  "metric.stream_clients": "观看客户端",
  "metric.total_captures": "拍照总数",
  "label.resolution": "分辨率",
  "label.jpeg_quality": "JPEG质量",
  "label.camera_led": "摄像头LED",
  "label.stream_profile": "模式",
  "stream.profile_auto": "自动",
  "stream.profile_stable": "稳定",
  "stream.profile_fast": "快速",
  "stream.mode_hint_auto_mjpeg": "自动：快速模式 (MJPEG)",
  "stream.mode_hint_auto_snapshot": "自动：因分辨率/运动切换稳定模式",
  "stream.mode_hint_forced_stable": "稳定模式开启（/capture 循环）",
  "stream.mode_hint_forced_fast": "快速模式开启（MJPEG）",
  "section.current_diagnosis": "当前诊断",
  "status.loading": "加载中...",
  "action.run_inference": "执行推理",
  "action.retry": "重试",
  "diagnosis.no_recent": "暂无最近推理",
  "diagnosis.waiting_data": "等待数据",
  "diagnosis.meta_line": "延迟 {latency} | HTTP {http} | 时间 {time}",
  "diagnosis.confidence": "置信度：{value}%",
  "diagnosis.reasons": "原因：{value}",
  "diagnosis.awaiting": "等待推理数据",
  "diagnosis.confident": "高置信",
  "diagnosis.low_confidence": "低置信",
  "diagnosis.fail": "推理失败",
  "diagnosis.no_data": "无数据",
  "sub.top_probabilities": "Top 概率",
  "sub.capture_context": "拍摄上下文",
  "state.no_data_show": "暂无可显示数据。",
  "state.no_recent_context": "暂无最近上下文",
  "chip.temp": "温度 {value}",
  "chip.air_humidity": "空气湿度 {value}",
  "chip.light": "光照 {value}",
  "chip.soil": "土壤 {value}",
  "chip.pump": "水泵 {value}",
  "pump.on": "开启",
  "pump.off": "关闭",
  "section.sensors": "环境传感器",
  "status.reading": "读取中...",
  "sensor.updated_ago": "{age} 前更新",
  "sensor.delayed": "读取延迟（{age}）",
  "sensor.stale": "无最近读取（{age}）",
  "sensor.soil_humidity": "土壤湿度",
  "sensor.soil_raw": "土壤原始值 (ADC)",
  "sensor.lux_raw": "光照 (ADC)",
  "sensor.temperature": "温度",
  "sensor.air_humidity": "空气湿度",
  "sensor.dht": "DHT22",
  "status.ok": "正常",
  "status.fail": "失败",
  "section.irrigation": "灌溉",
  "status.pump_off": "水泵关闭",
  "status.pump_on": "水泵开启",
  "status.cooldown_wait": "冷却等待中",
  "irrigation.auto_mode": "自动模式",
  "irrigation.pump_remaining": "水泵剩余时间",
  "irrigation.cooldown_remaining": "冷却剩余时间",
  "irrigation.dry_threshold": "土壤干燥阈值",
  "state.active": "启用",
  "state.disabled": "停用",
  "action.irrigate_now": "立即灌溉",
  "action.stop": "停止",
  "section.health": "系统健康与遥测",
  "status.no_sync": "未同步",
  "status.synced_at": "已同步 {time}",
  "health.heap_free": "可用堆内存",
  "health.psram_free": "可用PSRAM",
  "health.http_requests": "HTTP请求",
  "health.mqtt_pub": "MQTT发布",
  "health.mqtt_fail": "MQTT失败",
  "health.infer_ok": "推理成功",
  "section.events": "最近事件",
  "events.last_20": "最近20条事件",
  "events.none": "暂无事件",
  "section.tech_mode": "技术模式 (JSON)",
  "section.last_inference": "最近推理",
  "section.raw_debug": "原始调试",
  "dashboard.realtime": "实时仪表盘",
  "dashboard.live_now": "当前",
  "dashboard.trends": "趋势",
  "dashboard.last_cycles": "最近周期",
  "dashboard.inference_health": "推理健康度",
  "dashboard.model_view": "模型",
  "dashboard.success_rate": "成功率",
  "dashboard.last_latency": "最近延迟",
  "dashboard.infer_attempts": "尝试次数",
  "dashboard.infer_failures": "失败次数",
  "dashboard.pump_activity": "水泵活动",
  "dashboard.recent_window": "最近窗口",
  "dashboard.pump_duty": "占空比",
  "dashboard.range": "范围",
  "dashboard.export_csv": "导出 CSV",
  "tab.overview": "总览",
  "tab.camera": "摄像头",
  "tab.irrigation": "灌溉",
  "tab.technical": "技术",
  "stream.safe_mode": "安全视频模式",
  "stream.safe_mode_on": "安全模式已开启",
  "stream.safe_mode_off": "安全模式已关闭",
  "guided.infer_fail": "推理失败。请检查光照和对焦，并在较低分辨率下重试。",
  "guided.low_conf": "低置信度：{reasons}。建议操作：稳定画面后重新推理。",
  "camera.load_fail_reconnect": "视频流失败，正在重连...",
  "camera.stream_fail": "摄像头视频流失败",
  "camera.photo_captured": "已拍照",
  "camera.photo_capture_failed": "拍照失败",
  "camera.stream_resumed": "视频流已恢复",
  "camera.stream_paused": "视频流已暂停",
  "camera.quality_set": "JPEG质量已设置为 {value}",
  "camera.quality_set_fail": "设置质量失败",
  "camera.resolution_set": "分辨率已改为 {value}",
  "camera.resolution_set_fail": "修改分辨率失败",
  "camera.high_res_warning": "高运动下 VGA 可能卡顿。为稳定视频流，建议使用 QVGA/CIF。",
  "camera.led_set": "摄像头LED已设置为 {value}",
  "camera.led_set_fail": "设置摄像头LED失败",
  "refresh.done": "手动刷新完成",
  "refresh.done_toast": "刷新完成",
  "connection.restored": "连接已恢复",
  "connection.restored_toast": "连接已恢复",
  "sync.error": "同步错误：{error}",
  "sync.error_toast": "同步错误",
  "boot.started": "面板已启动",
  "boot.started_toast": "面板已启动",
  "boot.fail": "启动失败：{error}",
  "inference.requested": "已请求推理",
  "inference.requested_toast": "已请求推理",
  "inference.request_failed": "请求推理失败",
  "irrigation.started": "灌溉已启动，时长 {duration}",
  "irrigation.started_toast": "灌溉已启动",
  "irrigation.start_failed": "启动灌溉失败",
  "irrigation.stopped": "灌溉已手动停止",
  "irrigation.stopped_toast": "灌溉已停止",
  "irrigation.stop_failed": "停止灌溉失败",
  "generic.error": "错误：{error}",
  "generic.action_failed": "失败：{error}",
  "diagnosis.load_failed": "无法加载数据",
  "diagnosis.error_connection": "连接错误",
  "unit.ms": "毫秒",
  "unit.celsius": "C",
  "class.Tomato_Leaf_Mold": "叶霉病",
  "class.Tomato_Early_blight": "早疫病",
  "class.Tomato__Target_Spot": "靶斑病",
  "class.Tomato_Late_blight": "晚疫病",
  "class.Tomato_Septoria_leaf_spot": "斑点病",
  "class.Tomato_Bacterial_spot": "细菌性斑点",
  "class.Tomato_healthy": "健康叶片",
  "reason.low_light": "光照不足",
  "reason.blurry": "图像模糊",
  "reason.low_lux_skip": "因光照不足跳过",
  "reason.infer_host_empty": "未配置推理服务器",
  "reason.camera_fb_get_fail": "图像采集失败",
  "reason.http_fail": "推理通信失败",
  "reason.wifi_disconnected": "Wi-Fi 已断开",
  "reason.unknown": "未知故障",
  "label.language": "语言",
  "lang.pt": "PT",
  "lang.en": "EN",
  "lang.cn": "中文"
}
};

(function () {
  async function jget(path) {
    const r = await fetch(path, { cache: "no-store" });
    if (!r.ok) throw new Error(path + " " + r.status);
    return r.json();
  }

  async function jpost(path, body) {
    const r = await fetch(path, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(body || {})
    });
    if (!r.ok) throw new Error(path + " " + r.status);
    return r.json();
  }

  async function textget(path) {
    const r = await fetch(path, { cache: "no-store" });
    if (!r.ok) throw new Error(path + " " + r.status);
    return r.text();
  }

  async function refreshPayload() {
    const paths = [
      jget("/health"),
      jget("/api/sensors"),
      jget("/api/irrigation"),
      jget("/status"),
      jget("/metrics"),
      jget("/api/config"),
      jget("/api/inference/last")
    ];
    const [health, sensors, irrigation, camera, metrics, config, lastInfer] = await Promise.all(paths);
    return { health, sensors, irrigation, camera, metrics, config, lastInfer };
  }

  window.STGApi = { jget, jpost, textget, refreshPayload };
})();

(function () {
  const dicts = window.__STG_I18N_DICTS__ || {};
  let lang = "pt";

  function interpolate(text, params) {
    if (!params) return text;
    return String(text).replace(/\{(\w+)\}/g, function (_, k) {
      return params[k] != null ? String(params[k]) : "";
    });
  }

  function t(key, params) {
    const active = dicts[lang] || {};
    const fallback = dicts.pt || {};
    const raw = active[key] != null ? active[key] : (fallback[key] != null ? fallback[key] : key);
    return interpolate(raw, params);
  }

  function apply(root) {
    const node = root || document;
    const list = node.querySelectorAll("[data-i18n]");
    list.forEach(function (el) {
      const key = el.getAttribute("data-i18n");
      if (!key) return;
      el.textContent = t(key);
    });
  }

  function setLang(next) {
    if (!dicts[next]) return;
    lang = next;
    try { localStorage.setItem("stg_lang", lang); } catch (e) {}
    apply(document);
    document.documentElement.setAttribute("lang", next === "cn" ? "zh-CN" : next);
    document.dispatchEvent(new CustomEvent("stg:lang-changed", { detail: { lang: lang } }));
  }

  function getLang() {
    return lang;
  }

  function init() {
    let preferred = "pt";
    try {
      preferred = localStorage.getItem("stg_lang") || "pt";
    } catch (e) {}
    if (!dicts[preferred]) preferred = "pt";
    lang = preferred;
    apply(document);
  }

  window.STGI18n = { init, t, apply, setLang, getLang, dicts };
})();

(function () {
  function fmtMs(ms) {
    const n = Number(ms || 0);
    if (!Number.isFinite(n)) return "-";
    if (n < 1000) return n + " ms";
    const s = Math.round(n / 100) / 10;
    if (s < 60) return s + "s";
    const m = Math.floor(s / 60);
    const rs = Math.round(s % 60);
    return m + "m " + rs + "s";
  }

  function fmtPct(v, digits) {
    const n = Number(v);
    if (!Number.isFinite(n)) return "-";
    return n.toFixed(digits == null ? 1 : digits) + "%";
  }

  function toPctNum(v) {
    const n = Number(v);
    if (!Number.isFinite(n)) return null;
    return Math.max(0, Math.min(100, n * 100));
  }

  function fmtNum(v, digits) {
    const n = Number(v);
    if (!Number.isFinite(n)) return "-";
    return n.toFixed(digits == null ? 0 : digits);
  }

  function fmtClock(tsMs) {
    if (!Number.isFinite(Number(tsMs))) return "-";
    const msNow = Date.now();
    const uptimeNow = performance.now();
    const approxEpoch = msNow - uptimeNow + Number(tsMs);
    return new Date(approxEpoch).toLocaleTimeString();
  }

  window.STGFmt = { fmtMs, fmtPct, toPctNum, fmtNum, fmtClock };
})();

(function () {
  const CLASS_MAP = {
    Tomato_Leaf_Mold: "class.Tomato_Leaf_Mold",
    Tomato_Early_blight: "class.Tomato_Early_blight",
    Tomato__Target_Spot: "class.Tomato__Target_Spot",
    Tomato_Late_blight: "class.Tomato_Late_blight",
    Tomato_Septoria_leaf_spot: "class.Tomato_Septoria_leaf_spot",
    Tomato_Bacterial_spot: "class.Tomato_Bacterial_spot",
    Tomato_healthy: "class.Tomato_healthy"
  };

  const REASON_MAP = {
    low_light: "reason.low_light",
    blurry: "reason.blurry",
    low_lux_skip: "reason.low_lux_skip",
    infer_host_empty: "reason.infer_host_empty",
    camera_fb_get_fail: "reason.camera_fb_get_fail",
    http_fail: "reason.http_fail",
    wifi_disconnected: "reason.wifi_disconnected",
    unknown: "reason.unknown"
  };

  function labelClass(raw) {
    const t = window.STGI18n.t;
    if (!raw) return t("diagnosis.no_recent");
    const key = CLASS_MAP[raw];
    return key ? t(key) : raw;
  }

  function mapReasons(list) {
    const t = window.STGI18n.t;
    if (!Array.isArray(list)) return [];
    return list.filter(Boolean).map(function (r) {
      const key = REASON_MAP[r];
      return key ? t(key) : r;
    });
  }

  window.STGMap = { labelClass, mapReasons };
})();

(function () {
  function normalizeReasons(rawReasons) {
    if (Array.isArray(rawReasons)) return rawReasons;
    if (typeof rawReasons === "string" && rawReasons.trim()) {
      return rawReasons.split("|").map(function (s) { return s.trim(); }).filter(Boolean);
    }
    return [];
  }

  function parseRaw(raw) {
    if (!raw) return null;
    if (typeof raw === "object") return raw;
    if (typeof raw !== "string") return null;
    try {
      return JSON.parse(raw);
    } catch (e) {
      return null;
    }
  }

  function toViewModel(lastInfer) {
    const F = window.STGFmt;
    const M = window.STGMap;
    const t = window.STGI18n.t;
    const empty = {
      status: "empty",
      labelFriendly: t("diagnosis.no_recent"),
      labelRaw: "",
      confidencePct: null,
      confidenceBadge: t("diagnosis.no_data"),
      latencyMs: null,
      httpStatus: null,
      reasons: [],
      topk: [],
      context: { tempC: null, humPct: null, luxRaw: null, soilPct: null, pumpOn: null },
      rawPayload: null,
      tsMs: null
    };

    if (!lastInfer || typeof lastInfer !== "object" || Object.keys(lastInfer).length === 0) return empty;

    const rawPayload = parseRaw(lastInfer.raw);
    const predictedRaw =
      (rawPayload && (rawPayload.classe_predita || rawPayload.predicted || rawPayload.label || rawPayload.class)) ||
      lastInfer.predicted ||
      "";
    const confidenceRaw =
      (rawPayload && (rawPayload.score != null ? rawPayload.score : rawPayload.confidence)) != null
        ? (rawPayload.score != null ? rawPayload.score : rawPayload.confidence)
        : lastInfer.confidence;
    const confidencePct = F.toPctNum(confidenceRaw);
    const confident = Boolean((rawPayload && rawPayload.confident) != null ? rawPayload.confident : lastInfer.confident);
    const minConf = Number((rawPayload && rawPayload.min_confidence) != null ? rawPayload.min_confidence : 0.6);

    const reasonBase = normalizeReasons((rawPayload && rawPayload.reasons) != null ? rawPayload.reasons : lastInfer.reasons);
    const reasons = M.mapReasons(reasonBase);

    let status = "empty";
    let confidenceBadge = t("diagnosis.no_data");
    if (lastInfer.ok === false) {
      status = "fail";
      confidenceBadge = t("diagnosis.fail");
    } else if (predictedRaw || confidencePct != null) {
      if (confident && Number(confidenceRaw) >= minConf) {
        status = "ok";
        confidenceBadge = t("diagnosis.confident");
      } else {
        status = "low_confidence";
        confidenceBadge = t("diagnosis.low_confidence");
      }
    }

    const topkRaw = rawPayload && Array.isArray(rawPayload.topk) ? rawPayload.topk.slice(0, 3) : [];
    let topk = topkRaw.map(function (it) {
      const rawLabel = it.classe || it.class || it.label || "";
      const scorePct = F.toPctNum(it.score);
      return {
        labelFriendly: M.labelClass(rawLabel),
        labelRaw: rawLabel,
        scorePct: scorePct
      };
    });

    if (!topk.length && predictedRaw) {
      topk = [{
        labelFriendly: M.labelClass(predictedRaw),
        labelRaw: predictedRaw,
        scorePct: confidencePct
      }];
    }

    const meta = rawPayload && rawPayload.meta ? rawPayload.meta : {};
    const context = {
      tempC: meta.temp_c != null ? Number(meta.temp_c) : null,
      humPct: meta.hum_pct != null ? Number(meta.hum_pct) : null,
      luxRaw: meta.lux_raw != null ? Number(meta.lux_raw) : null,
      soilPct: meta.soil_pct != null ? Number(meta.soil_pct) : null,
      pumpOn: meta.pump_on != null ? Number(meta.pump_on) === 1 : null
    };

    return {
      status: status,
      labelFriendly: M.labelClass(predictedRaw),
      labelRaw: predictedRaw,
      confidencePct: confidencePct,
      confidenceBadge: confidenceBadge,
      latencyMs: Number(lastInfer.latency_ms),
      httpStatus: Number(lastInfer.http_status),
      reasons: reasons,
      topk: topk,
      context: context,
      rawPayload: rawPayload,
      tsMs: Number(lastInfer.ts_ms),
      ok: lastInfer.ok !== false
    };
  }

  window.STGInference = { toViewModel };
})();

(function () {
  function $(id) { return document.getElementById(id); }
  function t(key, params) { return window.STGI18n.t(key, params); }

  function setBadge(elId, text, cls) {
    const node = $(elId);
    node.textContent = text;
    node.className = ("status " + (cls || "")).trim();
  }

  function gaugeColor(pct) {
    if (pct < 33) return "#c9743f";
    if (pct < 66) return "#c3a53c";
    return "#58b576";
  }

  function setGauge(id, pct) {
    const node = $(id);
    const safe = Math.max(0, Math.min(100, Number(pct) || 0));
    const color = gaugeColor(safe);
    node.style.background = "conic-gradient(" + color + " " + (safe * 3.6) + "deg, #e7efe4 0deg)";
  }

  function drawSparkline(canvasId, values, color) {
    const cvs = $(canvasId);
    if (!cvs) return;
    const ctx = cvs.getContext("2d");
    const w = cvs.width;
    const h = cvs.height;
    ctx.clearRect(0, 0, w, h);

    const clean = (values || []).map(function (v) { return Number(v); }).filter(function (n) { return Number.isFinite(n); });
    if (clean.length < 2) {
      ctx.strokeStyle = "rgba(90,120,100,.45)";
      ctx.beginPath();
      ctx.moveTo(0, h * .6);
      ctx.lineTo(w, h * .6);
      ctx.stroke();
      return;
    }

    let min = Math.min.apply(null, clean);
    let max = Math.max.apply(null, clean);
    if (max - min < 0.0001) max = min + 1;

    ctx.strokeStyle = color;
    ctx.lineWidth = 2;
    ctx.beginPath();
    for (let i = 0; i < clean.length; i++) {
      const x = (i / (clean.length - 1)) * (w - 1);
      const norm = (clean[i] - min) / (max - min);
      const y = h - 12 - norm * (h - 24);
      if (i === 0) ctx.moveTo(x, y);
      else ctx.lineTo(x, y);
    }
    ctx.stroke();
  }

  function setSyncState(text, cls) {
    const node = $("syncState");
    node.textContent = text;
    node.className = ("tiny syncState " + (cls || "")).trim();
  }

  function setCameraLoading(on, text) {
    const overlay = $("cameraOverlay");
    overlay.classList.toggle("loading", Boolean(on));
    if (text) {
      const span = overlay.querySelector("span:last-child");
      if (span) span.textContent = text;
    }
  }

  function showToast(text, kind, ttlMs) {
    const stack = $("toastStack");
    if (!stack) return;
    const el = document.createElement("div");
    el.className = ("toast " + (kind || "")).trim();
    el.textContent = text;
    stack.appendChild(el);
    setTimeout(function () {
      if (el && el.parentNode) el.parentNode.removeChild(el);
    }, ttlMs || 2400);
  }

  function setSystem(payload) {
    const F = window.STGFmt;
    const health = payload.health;
    const sensors = payload.sensors;
    const irrigation = payload.irrigation;
    const camera = payload.camera;
    const metrics = payload.metrics;
    const config = payload.config;

    $("device").textContent = health.device_id || "-";
    $("ip").textContent = health.ip || "-";
    $("rssi").textContent = health.rssi + " dBm";
    $("uptime").textContent = F.fmtMs(health.uptime_ms);
    $("heap").textContent = String(health.heap || "-");
    $("psram").textContent = String(health.psram || "-");
    $("inferOk").textContent = String(metrics.infer_ok || 0);

    setBadge("onlineState", health.online ? t("status.online") : t("status.offline"), health.online ? "ok" : "bad");
    if (!health.online) setSyncState(t("status.offline"), "bad");

    const age = Number(sensors.age_ms || 0);
    if (age <= 4000) setBadge("sensorFresh", t("sensor.updated_ago", { age: F.fmtMs(age) }), "ok");
    else if (age <= 10000) setBadge("sensorFresh", t("sensor.delayed", { age: F.fmtMs(age) }), "warn");
    else setBadge("sensorFresh", t("sensor.stale", { age: F.fmtMs(age) }), "bad");

    $("soilRaw").textContent = String(sensors.soil_raw ?? "-");
    $("soilPct").textContent = F.fmtPct(sensors.soil_pct, 1);
    $("luxRaw").textContent = String(sensors.lux_raw ?? "-");
    $("tempC").textContent = F.fmtNum(sensors.temp_c, 1) + " " + t("unit.celsius");
    $("humPct").textContent = F.fmtPct(sensors.hum_pct, 1);
    $("dhtOk").textContent = sensors.dht_ok ? t("status.ok") : t("status.fail");

    $("autoMode").textContent = irrigation.auto_enabled ? t("state.active") : t("state.disabled");
    $("pumpRemaining").textContent = F.fmtMs(irrigation.remaining_ms || 0);
    $("cooldownRemaining").textContent = F.fmtMs(irrigation.cooldown_remaining_ms || 0);
    $("dryThreshold").textContent = (irrigation.soil_dry_threshold_pct ?? config.soil_dry_threshold_pct) + "%";

    if (irrigation.pump_on) setBadge("pumpState", t("status.pump_on"), "ok");
    else if ((irrigation.cooldown_remaining_ms || 0) > 0) setBadge("pumpState", t("status.cooldown_wait"), "warn");
    else setBadge("pumpState", t("status.pump_off"), "");

    $("quality").value = camera.quality;
    $("qualityV").textContent = String(camera.quality);
    $("framesize").value = camera.framesize;
    $("led").value = camera.led_intensity;
    $("ledV").textContent = String(camera.led_intensity);

    $("streamClients").textContent = String(metrics.stream_clients || 0);
    $("captureCount").textContent = String(metrics.capture || 0);
    $("httpCount").textContent = String(metrics.http || 0);
    $("mqttPub").textContent = String(metrics.mqtt_pub || 0);
    $("mqttFail").textContent = String(metrics.mqtt_fail || 0);
    $("lastSync").textContent = t("status.synced_at", { time: new Date().toLocaleTimeString() });
  }

  function setInference(vm, rawLastInfer) {
    const F = window.STGFmt;
    const diagCard = $("diagnosisCard");
    const main = $("diagnosisMain");
    main.classList.remove("loading");
    diagCard.classList.remove("ok", "warn", "bad");
    $("btnRetrySync").classList.add("hidden");

    let cls = "";
    if (vm.status === "ok") cls = "ok";
    if (vm.status === "low_confidence") cls = "warn";
    if (vm.status === "fail") cls = "bad";
    if (cls) diagCard.classList.add(cls);

    if (vm.status === "ok") setBadge("diagnosisStatus", vm.confidenceBadge, "ok");
    else if (vm.status === "low_confidence") setBadge("diagnosisStatus", vm.confidenceBadge, "warn");
    else if (vm.status === "fail") setBadge("diagnosisStatus", vm.confidenceBadge, "bad");
    else setBadge("diagnosisStatus", vm.confidenceBadge, "");

    $("diagLabel").textContent = vm.labelFriendly || t("diagnosis.no_recent");
    if (vm.confidencePct != null) {
      $("diagSub").textContent = t("diagnosis.confidence", { value: F.fmtNum(vm.confidencePct, 1) });
    } else if (vm.reasons.length) {
      $("diagSub").textContent = t("diagnosis.reasons", { value: vm.reasons.join(", ") });
    } else {
      $("diagSub").textContent = t("diagnosis.awaiting");
    }
    $("diagMeta").textContent = t("diagnosis.meta_line", {
      latency: F.fmtMs(vm.latencyMs),
      http: Number.isFinite(vm.httpStatus) ? vm.httpStatus : "-",
      time: F.fmtClock(vm.tsMs)
    });

    const topkList = $("topkList");
    topkList.innerHTML = "";
    if (!vm.topk.length) {
      topkList.innerHTML = '<p class="tiny">' + t("state.no_data_show") + "</p>";
    } else {
      vm.topk.forEach(function (row) {
        const pctText = row.scorePct == null ? "-" : F.fmtNum(row.scorePct, 1) + "%";
        const pctWidth = row.scorePct == null ? 0 : row.scorePct;
        const el = document.createElement("div");
        el.innerHTML =
          '<div class="barRow"><span>' + row.labelFriendly + '</span><strong>' + pctText + '</strong></div>' +
          '<div class="bar"><i style="width:' + pctWidth + '%"></i></div>';
        topkList.appendChild(el);
      });
    }

    const chips = $("contextChips");
    chips.innerHTML = "";
    const ctx = vm.context || {};
    const items = [
      t("chip.temp", { value: Number.isFinite(ctx.tempC) ? F.fmtNum(ctx.tempC, 1) + " " + t("unit.celsius") : "-" }),
      t("chip.air_humidity", { value: Number.isFinite(ctx.humPct) ? F.fmtNum(ctx.humPct, 1) + "%" : "-" }),
      t("chip.light", { value: Number.isFinite(ctx.luxRaw) ? String(ctx.luxRaw) : "-" }),
      t("chip.soil", { value: Number.isFinite(ctx.soilPct) ? F.fmtNum(ctx.soilPct, 1) + "%" : "-" }),
      t("chip.pump", { value: ctx.pumpOn == null ? "-" : (ctx.pumpOn ? t("pump.on") : t("pump.off")) })
    ];
    items.forEach(function (txt) {
      const chip = document.createElement("span");
      chip.className = "chip";
      chip.textContent = txt;
      chips.appendChild(chip);
    });

    $("inferenceJson").textContent = JSON.stringify(rawLastInfer || {}, null, 2);
  }

  function setRaw(payload) {
    $("rawJson").textContent = JSON.stringify(payload, null, 2);
  }

  function setGuidedAlert(vm) {
    const t = window.STGI18n.t;
    const box = $("guidedAlert");
    if (!box) return;
    box.classList.add("hidden");

    if (!vm) return;
    if (vm.status === "fail") {
      box.textContent = t("guided.infer_fail");
      box.classList.remove("hidden");
      return;
    }
    if (vm.status === "low_confidence" && vm.reasons && vm.reasons.length) {
      box.textContent = t("guided.low_conf", { reasons: vm.reasons.join(", ") });
      box.classList.remove("hidden");
      return;
    }
  }

  function setDashboard(payload, vm, hist) {
    const F = window.STGFmt;
    const t = window.STGI18n.t;
    const sensors = payload.sensors || {};
    const metrics = payload.metrics || {};

    const soilPct = Number(sensors.soil_pct);
    const humPct = Number(sensors.hum_pct);
    const tempC = Number(sensors.temp_c);

    setGauge("gaugeSoil", soilPct);
    setGauge("gaugeHum", humPct);
    // temp mapped to 10..40 C for a horticulture-friendly visual scale
    const tempNorm = ((tempC - 10) / 30) * 100;
    setGauge("gaugeTemp", tempNorm);

    $("gaugeSoilV").textContent = Number.isFinite(soilPct) ? F.fmtNum(soilPct, 1) + "%" : "-";
    $("gaugeHumV").textContent = Number.isFinite(humPct) ? F.fmtNum(humPct, 1) + "%" : "-";
    $("gaugeTempV").textContent = Number.isFinite(tempC) ? F.fmtNum(tempC, 1) + " " + t("unit.celsius") : "-";

    drawSparkline("trendTemp", hist.temp, "#4eaa68");
    drawSparkline("trendSoil", hist.soil, "#2f8f48");
    const cleanTemp = (hist.temp || []).map(function (n) { return Number(n); }).filter(function (n) { return Number.isFinite(n); });
    const cleanSoil = (hist.soil || []).map(function (n) { return Number(n); }).filter(function (n) { return Number.isFinite(n); });
    if (cleanTemp.length) {
      const tMin = Math.min.apply(null, cleanTemp);
      const tMax = Math.max.apply(null, cleanTemp);
      $("trendTempMeta").textContent = F.fmtNum(tMin, 1) + " - " + F.fmtNum(tMax, 1) + " " + t("unit.celsius");
    } else {
      $("trendTempMeta").textContent = "-";
    }
    if (cleanSoil.length) {
      const sMin = Math.min.apply(null, cleanSoil);
      const sMax = Math.max.apply(null, cleanSoil);
      $("trendSoilMeta").textContent = F.fmtNum(sMin, 1) + "% - " + F.fmtNum(sMax, 1) + "%";
    } else {
      $("trendSoilMeta").textContent = "-";
    }

    const attempts = Number(metrics.infer_attempt || 0);
    const ok = Number(metrics.infer_ok || 0);
    const fail = Number(metrics.infer_fail || 0);
    const rate = attempts > 0 ? (ok / attempts) * 100 : 0;
    const ring = $("inferRing");
    ring.style.background = "conic-gradient(#6fc082 " + (rate * 3.6) + "deg, #e7efe4 0deg)";
    $("inferRate").textContent = attempts > 0 ? F.fmtNum(rate, 1) + "%" : "-";
    $("inferAttempt").textContent = String(attempts);
    $("inferFail").textContent = String(fail);
    $("inferLatency").textContent = Number.isFinite(vm.latencyMs) ? F.fmtMs(vm.latencyMs) : "-";

    const timeline = $("pumpTimeline");
    timeline.innerHTML = "";
    const pumpHist = hist.pump.slice(-30);
    for (let i = 0; i < 30; i++) {
      const v = pumpHist[i] || 0;
      const bar = document.createElement("i");
      if (v) bar.className = "on";
      timeline.appendChild(bar);
    }
    const onCount = pumpHist.reduce(function (acc, n) { return acc + (n ? 1 : 0); }, 0);
    const duty = pumpHist.length ? (onCount / pumpHist.length) * 100 : 0;
    $("pumpDuty").textContent = F.fmtNum(duty, 1) + "%";
  }

  function setError(err) {
    setBadge("onlineState", t("status.sync_fail"), "bad");
    setSyncState(t("status.no_connection"), "bad");
    setBadge("diagnosisStatus", t("diagnosis.error_connection"), "bad");
    $("diagLabel").textContent = t("diagnosis.load_failed");
    $("diagSub").textContent = err && err.message ? err.message : "erro desconhecido";
    $("btnRetrySync").classList.remove("hidden");
    $("diagnosisCard").classList.remove("ok", "warn");
    $("diagnosisCard").classList.add("bad");
    $("diagnosisMain").classList.remove("loading");
    setCameraLoading(false);
  }

  window.STGRender = {
    $,
    setBadge,
    setSyncState,
    setCameraLoading,
    showToast,
    setSystem,
    setInference,
    setRaw,
    setError
    ,
    setDashboard,
    setGuidedAlert
  };
})();

(function () {
  const R = window.STGRender;
  const A = window.STGApi;
  const I = window.STGInference;
  const F = window.STGFmt;
  const T = window.STGI18n;
  function t(key, params) { return T.t(key, params); }

  const state = {
    streaming: true,
    feed: [],
    refreshInFlight: null,
    streamTick: null,
    snapshotTick: null,
    streamProfile: "auto",
    lastInferTs: 0,
    reconnectCount: 0,
    fpsFrameCount: 0,
    fpsLastTs: 0,
    fpsEstimate: 0,
    pollTimer: null,
    pollMs: 3500,
    hist: {
      temp: [],
      soil: [],
      pump: [],
      ts: []
    }
  };
  const HIGH_RES_STREAM_FS = 8; // VGA+
  const MID_RES_STREAM_FS = 6; // CIF+

  function pushHist(arr, value, max) {
    arr.push(value);
    while (arr.length > max) arr.shift();
  }

  function rangeToMs(v) {
    if (v === "5m") return 5 * 60 * 1000;
    if (v === "2h") return 2 * 60 * 60 * 1000;
    return 30 * 60 * 1000;
  }

  function filteredHistory() {
    const range = R.$("trendRange") ? R.$("trendRange").value : "30m";
    const windowMs = rangeToMs(range);
    const now = Date.now();
    const out = { temp: [], soil: [], pump: [] };
    for (let i = 0; i < state.hist.ts.length; i++) {
      if (now - state.hist.ts[i] <= windowMs) {
        out.temp.push(state.hist.temp[i]);
        out.soil.push(state.hist.soil[i]);
        out.pump.push(state.hist.pump[i]);
      }
    }
    return out;
  }

  function exportTrendCsv() {
    const h = filteredHistory();
    if (!h.temp.length) return;
    const rows = ["idx,temp_c,soil_pct,pump_on"];
    for (let i = 0; i < h.temp.length; i++) {
      rows.push([i, h.temp[i], h.soil[i], h.pump[i]].join(","));
    }
    const blob = new Blob([rows.join("\n")], { type: "text/csv;charset=utf-8" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = "stg_trends.csv";
    a.click();
    URL.revokeObjectURL(url);
  }

  function sleep(ms) {
    return new Promise(function (resolve) { setTimeout(resolve, ms); });
  }

  function pushFeed(kind, msg) {
    const time = new Date().toLocaleTimeString();
    state.feed.unshift({ kind: kind, msg: msg, time: time });
    state.feed = state.feed.slice(0, 20);
    const ul = R.$("feed");
    ul.innerHTML = "";
    if (!state.feed.length) {
      const empty = document.createElement("li");
      empty.className = "emptyFeed";
      empty.textContent = t("events.none");
      ul.appendChild(empty);
      return;
    }
    state.feed.forEach(function (line) {
      const li = document.createElement("li");
      const tag = document.createElement("span");
      tag.className = "feedTag";
      tag.textContent = line.kind;
      li.appendChild(tag);
      li.appendChild(document.createTextNode("[" + line.time + "] " + line.msg));
      ul.appendChild(li);
    });
  }

  function setBtnLoading(id, on, busyText) {
    const btn = R.$(id);
    if (!btn) return;
    if (!btn.dataset.idleText) btn.dataset.idleText = btn.textContent;
    if (on) {
      btn.disabled = true;
      btn.classList.add("is-loading");
      if (busyText) btn.textContent = t(busyText);
    } else {
      btn.disabled = false;
      btn.classList.remove("is-loading");
      btn.textContent = btn.dataset.idleText;
    }
  }

  function setHud() {
    const transport = shouldUseSnapshotLoop() ? "snapshot" : "mjpeg";
    R.$("hudTransport").textContent = "mode " + transport;
    R.$("hudFps").textContent = "fps " + (state.fpsEstimate ? state.fpsEstimate.toFixed(1) : "-");
    R.$("hudReconnect").textContent = "reconnect " + state.reconnectCount;
  }

  async function runAction(meta, fn) {
    const id = meta.id;
    try {
      setBtnLoading(id, true, meta.busyText);
      await fn();
      if (meta.toastOk) R.showToast(t(meta.toastOk), "ok");
    } catch (err) {
      const msg = err && err.message ? err.message : "erro inesperado";
      pushFeed(meta.feedKind || "sistema", t("generic.error", { error: msg }));
      R.showToast(meta.toastErr ? t(meta.toastErr) : t("generic.action_failed", { error: msg }), "bad", 3200);
      return false;
    } finally {
      setBtnLoading(id, false);
    }
    return true;
  }

  function updateStream(on) {
    state.streaming = on;
    stopStreamLoops();
    R.setCameraLoading(true, on ? t("loading.camera") : t("loading.capture"));
    if (on) startStreamTransport();
    else R.$("view").src = "/capture?ts=" + Date.now();
    R.$("btnStream").textContent = on ? t("action.pause_stream") : t("action.resume_stream");
    R.setBadge("streamState", on ? t("status.stream_active") : t("status.stream_paused"), on ? "ok" : "warn");
  }

  function isHighResStream() {
    const fs = Number(R.$("framesize").value || 0);
    return fs >= HIGH_RES_STREAM_FS;
  }

  function isMidOrHighResStream() {
    const fs = Number(R.$("framesize").value || 0);
    return fs >= MID_RES_STREAM_FS;
  }

  function shouldUseSnapshotLoop() {
    if (state.streamProfile === "stable") return true;
    if (state.streamProfile === "fast") return false;
    return isMidOrHighResStream();
  }

  function streamIntervalMs() {
    const fs = Number(R.$("framesize").value || 0);
    if (fs >= 10) return 1100;
    if (fs >= 9) return 900;
    if (fs >= 8) return 700;
    if (fs >= 6) return 550;
    return 420;
  }

  function setStreamHint() {
    const hint = R.$("streamHint");
    if (!hint) return;
    let key = "stream.mode_hint_auto_mjpeg";
    if (state.streamProfile === "stable") key = "stream.mode_hint_forced_stable";
    else if (state.streamProfile === "fast") key = "stream.mode_hint_forced_fast";
    else if (shouldUseSnapshotLoop()) key = "stream.mode_hint_auto_snapshot";
    hint.textContent = t(key);
    setHud();
  }

  function stopStreamLoops() {
    if (state.streamTick) clearInterval(state.streamTick);
    if (state.snapshotTick) clearTimeout(state.snapshotTick);
    state.streamTick = null;
    state.snapshotTick = null;
  }

  function snapshotFrameLoop() {
    if (!state.streaming) return;
    R.$("view").src = "/capture?ts=" + Date.now();
    state.snapshotTick = setTimeout(snapshotFrameLoop, streamIntervalMs());
  }

  function startStreamTransport() {
    setStreamHint();
    if (shouldUseSnapshotLoop()) {
      snapshotFrameLoop();
      return;
    }
    R.$("view").src = "/stream?ts=" + Date.now();
    streamWatchdogStart();
  }

  function streamWatchdogStart() {
    if (state.streamTick) clearInterval(state.streamTick);
    state.streamTick = setInterval(function () {
      if (!state.streaming) return;
      if (shouldUseSnapshotLoop()) return;
      if (!isHighResStream()) return;
      // Refresh MJPEG connection periodically in high-res mode to reduce stuck streams.
      R.$("view").src = "/stream?ts=" + Date.now();
    }, 12000);
  }

  async function cameraControl(name, value) {
    await A.textget("/control?var=" + encodeURIComponent(name) + "&val=" + encodeURIComponent(String(value)));
  }

  async function irrigate(ms) {
    const prevTxt = R.$("pumpState").textContent;
    const prevCls = R.$("pumpState").className;
    R.setBadge("pumpState", t("status.pump_on"), "ok");
    await A.jpost("/api/irrigation/start", { ms: ms });
    pushFeed("irrigacao", t("irrigation.started", { duration: F.fmtMs(ms) }));
    try {
      await refreshAll();
    } catch (err) {
      R.$("pumpState").textContent = prevTxt;
      R.$("pumpState").className = prevCls;
      throw err;
    }
  }

  async function stopIrrigation() {
    const prevTxt = R.$("pumpState").textContent;
    const prevCls = R.$("pumpState").className;
    R.setBadge("pumpState", t("status.pump_off"), "");
    await A.jpost("/api/irrigation/stop", {});
    pushFeed("irrigacao", t("irrigation.stopped"));
    try {
      await refreshAll();
    } catch (err) {
      R.$("pumpState").textContent = prevTxt;
      R.$("pumpState").className = prevCls;
      throw err;
    }
  }

  async function refreshAll(opts) {
    const options = opts || {};
    if (state.refreshInFlight) return state.refreshInFlight;
    R.setSyncState(t("status.syncing"), "");
    if (!options.silent) setBtnLoading("btnRefresh", true, "action.refresh_all");

    state.refreshInFlight = (async function () {
    const payload = await A.refreshPayload();
    R.setSystem(payload);
    const vm = I.toViewModel(payload.lastInfer);
    state.lastInferTs = Number(payload.lastInfer && payload.lastInfer.ts_ms) || state.lastInferTs;
    pushHist(state.hist.temp, Number(payload.sensors && payload.sensors.temp_c), 2200);
    pushHist(state.hist.soil, Number(payload.sensors && payload.sensors.soil_pct), 2200);
    pushHist(state.hist.ts, Date.now(), 2200);
    state.hist.pump.push(payload.irrigation && payload.irrigation.pump_on ? 1 : 0);
    while (state.hist.pump.length > 2200) state.hist.pump.shift();
    R.setInference(vm, payload.lastInfer);
    R.setGuidedAlert(vm);
    R.setDashboard(payload, vm, filteredHistory());
    R.setRaw(payload);
      R.setSyncState(t("status.updated_now"), "");
    })();

    try {
      await state.refreshInFlight;
    } finally {
      state.refreshInFlight = null;
      if (!options.silent) setBtnLoading("btnRefresh", false);
    }
  }

  function bindUi() {
    const tabs = Array.prototype.slice.call(document.querySelectorAll(".tab"));
    const panels = Array.prototype.slice.call(document.querySelectorAll(".panel"));
    function activateTab(name) {
      tabs.forEach(function (b) { b.classList.toggle("is-active", b.dataset.tab === name); });
      panels.forEach(function (p) {
        const opts = (p.dataset.panel || "overview").split(" ");
        p.classList.toggle("is-hidden", opts.indexOf(name) < 0);
      });
    }
    tabs.forEach(function (btn) {
      btn.addEventListener("click", function () {
        activateTab(btn.dataset.tab || "overview");
      });
    });
    activateTab("overview");

    const camera = R.$("view");
    camera.addEventListener("load", function () {
      const now = performance.now();
      state.fpsFrameCount++;
      if (!state.fpsLastTs) state.fpsLastTs = now;
      const dt = now - state.fpsLastTs;
      if (dt >= 1000) {
        state.fpsEstimate = (state.fpsFrameCount * 1000) / dt;
        state.fpsFrameCount = 0;
        state.fpsLastTs = now;
        setHud();
      }
      R.setCameraLoading(false);
    });
    camera.addEventListener("error", function () {
      state.reconnectCount++;
      R.setCameraLoading(true, t("camera.load_fail_reconnect"));
      R.showToast(t("camera.stream_fail"), "warn");
      pushFeed("camera", t("camera.stream_fail"));
      if (state.streaming) {
        stopStreamLoops();
        setTimeout(function () { if (state.streaming) startStreamTransport(); }, 900);
      }
      setHud();
    });

    R.$("btnStream").addEventListener("click", function () {
      updateStream(!state.streaming);
      pushFeed("camera", state.streaming ? t("camera.stream_resumed") : t("camera.stream_paused"));
    });

    R.$("btnSnap").addEventListener("click", async function () {
      await runAction(
        { id: "btnSnap", busyText: "action.capture_photo", toastOk: "camera.photo_captured", toastErr: "camera.photo_capture_failed", feedKind: "camera" },
        async function () {
          const r = await fetch("/capture", { cache: "no-store" });
          if (!r.ok) throw new Error("capture " + r.status);
          const blob = await r.blob();
          const url = URL.createObjectURL(blob);
          window.open(url, "_blank");
          pushFeed("camera", t("camera.photo_captured"));
        }
      );
    });

    R.$("btnRefresh").addEventListener("click", async function () {
      await refreshAll({ silent: false });
      pushFeed("sistema", t("refresh.done"));
      R.showToast(t("refresh.done_toast"), "ok");
    });

    R.$("btnRetrySync").addEventListener("click", async function () {
      await refreshAll({ silent: false });
      pushFeed("sistema", t("connection.restored"));
      R.showToast(t("connection.restored_toast"), "ok");
    });

    R.$("btnIrrigate").addEventListener("click", async function () {
      await runAction(
        { id: "btnIrrigate", busyText: "action.irrigate_now", toastOk: "irrigation.started_toast", toastErr: "irrigation.start_failed", feedKind: "irrigacao" },
        async function () {
          const ms = Math.max(200, Math.min(30000, Number(R.$("irrigationMs").value || 1500)));
          R.$("irrigationMs").value = String(ms);
          await irrigate(ms);
        }
      );
    });

    Array.prototype.forEach.call(document.querySelectorAll("button.quick"), function (btn) {
      btn.addEventListener("click", async function () {
        const ms = Number(btn.dataset.ms || 1500);
        R.$("irrigationMs").value = String(ms);
        await runAction(
          { id: btn.id || "btnIrrigate", busyText: "action.irrigate_now", toastOk: "irrigation.started_toast", toastErr: "irrigation.start_failed", feedKind: "irrigacao" },
          async function () { await irrigate(ms); }
        );
      });
    });

    R.$("btnStop").addEventListener("click", async function () {
      await runAction(
        { id: "btnStop", busyText: "action.stop", toastOk: "irrigation.stopped_toast", toastErr: "irrigation.stop_failed", feedKind: "irrigacao" },
        stopIrrigation
      );
    });

    R.$("btnRunInference").addEventListener("click", async function () {
      await runAction(
        { id: "btnRunInference", busyText: "action.run_inference", toastOk: "inference.requested_toast", toastErr: "inference.request_failed", feedKind: "inferencia" },
        async function () {
          const wasStreaming = state.streaming;
          const prevTs = Number(state.lastInferTs || 0);
          if (wasStreaming) {
            updateStream(false);
            await sleep(220);
          }

          R.$("diagnosisMain").classList.add("loading");
          await A.jpost("/api/inference/run", {});
          pushFeed("inferencia", t("inference.requested"));

          // Wait for a fresh inference cycle before resuming the stream.
          const start = Date.now();
          while (Date.now() - start < 5000) {
            await sleep(380);
            let last = null;
            try {
              last = await A.jget("/api/inference/last");
            } catch (e) {
              continue;
            }
            const ts = Number(last && last.ts_ms) || 0;
            if (ts > prevTs) break;
          }

          await refreshAll({ silent: true });
          if (wasStreaming) {
            updateStream(true);
          }
        }
      );
    });

    R.$("quality").addEventListener("input", function () {
      R.$("qualityV").textContent = R.$("quality").value;
    });
    R.$("led").addEventListener("input", function () {
      R.$("ledV").textContent = R.$("led").value;
    });

    R.$("quality").addEventListener("change", async function () {
      try {
        await cameraControl("quality", R.$("quality").value);
        pushFeed("camera", t("camera.quality_set", { value: R.$("quality").value }));
      } catch (err) {
        R.showToast(t("camera.quality_set_fail"), "bad");
      }
    });

    R.$("framesize").addEventListener("change", async function () {
      try {
        await cameraControl("framesize", R.$("framesize").value);
        pushFeed("camera", t("camera.resolution_set", { value: R.$("framesize").selectedOptions[0].textContent }));
        if (state.streaming) {
          stopStreamLoops();
          startStreamTransport();
        }
        if (isHighResStream()) {
          R.showToast(t("camera.high_res_warning"), "warn", 3800);
          pushFeed("camera", t("camera.high_res_warning"));
        }
      } catch (err) {
        R.showToast(t("camera.resolution_set_fail"), "bad");
      }
    });

    R.$("led").addEventListener("change", async function () {
      try {
        await cameraControl("led_intensity", R.$("led").value);
        pushFeed("camera", t("camera.led_set", { value: R.$("led").value }));
      } catch (err) {
        R.showToast(t("camera.led_set_fail"), "bad");
      }
    });

    R.$("langSelect").addEventListener("change", function () {
      T.setLang(R.$("langSelect").value);
      updateStream(state.streaming);
      pushFeed("sistema", "LANG " + T.getLang());
      refreshAll({ silent: true }).catch(function () {});
    });
    R.$("streamProfile").addEventListener("change", function () {
      state.streamProfile = R.$("streamProfile").value || "auto";
      setStreamHint();
      if (state.streaming) {
        stopStreamLoops();
        startStreamTransport();
      }
    });
    R.$("safeMode").addEventListener("change", function () {
      const on = Boolean(R.$("safeMode").checked);
      if (on) {
        state.pollMs = 6000;
        state.streamProfile = "stable";
        R.$("streamProfile").value = "stable";
        R.showToast(t("stream.safe_mode_on"), "warn");
      } else {
        state.pollMs = 3500;
        state.streamProfile = "auto";
        R.$("streamProfile").value = "auto";
        R.showToast(t("stream.safe_mode_off"), "ok");
      }
      if (state.streaming) {
        stopStreamLoops();
        startStreamTransport();
      }
      startPolling();
    });
    R.$("trendRange").addEventListener("change", function () {
      refreshAll({ silent: true }).catch(function () {});
    });
    R.$("btnExportTrends").addEventListener("click", exportTrendCsv);
    document.addEventListener("stg:lang-changed", function () {
      R.$("langSelect").value = T.getLang();
      setStreamHint();
      Array.prototype.forEach.call(document.querySelectorAll("button"), function (btn) {
        delete btn.dataset.idleText;
      });
    });
  }

  function startPolling() {
    if (state.pollTimer) clearInterval(state.pollTimer);
    state.pollTimer = setInterval(function () {
      refreshAll({ silent: true }).catch(function (err) {
        R.setError(err);
        pushFeed("sistema", t("sync.error", { error: err.message }));
        R.showToast(t("sync.error_toast"), "warn");
      });
    }, state.pollMs);
  }

  async function boot() {
    T.init();
    R.$("langSelect").value = T.getLang();
    state.streamProfile = R.$("streamProfile").value || "auto";
    bindUi();
    setStreamHint();
    setHud();
    R.setCameraLoading(true, t("loading.camera"));
    updateStream(true);
    await refreshAll({ silent: false });
    pushFeed("sistema", t("boot.started"));
    R.showToast(t("boot.started_toast"), "ok", 1700);

    startPolling();
  }

  boot().catch(function (err) {
    R.setError(err);
    pushFeed("sistema", t("boot.fail", { error: err.message }));
    R.$("rawJson").textContent = String(err);
  });
})();
  </script>
</body>
</html>
